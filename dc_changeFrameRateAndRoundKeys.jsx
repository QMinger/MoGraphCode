/** * UIBuilder - Simple object which builds a UI. * * @return {undefined}  None. */var UIBuilder = function(){  this.w;  this.pbar;}/** * UIBuilder.makeWindow - simple method which builds a window with 2 * pieces of static text and a progress bar. Starts with default values. * * @return {undefined}  None. */UIBuilder.prototype.makeWindow = function () {  this.w = new Window('window', 'dc_changeFrameRateAndRoundKeys');  this.w.add('statictext',undefined,'Processing Project. This may take several moments.');  this.w.pbar = this.w.add('progressbar',undefined,0,100);  this.w.counter = this.w.add('statictext',undefined,'Waiting.',{multiline:true});  this.w.pbar.preferredSize.width = 300;  this.w.counter.preferredSize.width = 300;  this.w.counter.preferredSize.height = 50;  this.w.show();};/** * KeyframeRounder - Object which handles the rounding of keyframes to the * nearest whole frame. * * @return {undefined}  None. */var KeyframeRounder = function(){  this.project = app.project;  this.projectItems = {    folders: [],    comps: [],    footage: [],    solids: []  };  this.tracks = [];  this.keyCount = 0;  this.cntr = 1;  this.fr = 23.976,  this.fd = 1/this.fr  this.errors = [];};/** * KeyframeRounder.prototype.filterProject - Goes through each project item and * sorts it into the this.projectItems object according to type. * * @return {undefined} None. */KeyframeRounder.prototype.filterProject = function(){  pal.makeWindow();  pal.w.pbar.value = 0;  pal.w.pbar.maxvalue = this.project.numItems;  for(var i = 1; i <= this.project.numItems; i++){    var itm = this.project.item(i);    switch(itm.typeName){      case 'Folder':        this.projectItems.folders.push(itm);        break;      case 'Composition':        this.projectItems.comps.push(itm);        break;      case 'Footage':        if (itm.mainSource instanceof FileSource){          this.projectItems.footage.push(itm);        } else {          this.projectItems.solids.push(itm);        }        break;      default:        break;    }    pal.w.pbar.value = i+1;    pal.w.counter.text = 'Processing project item ' + i + ' of ' + this.project.numItems;  }  pal.w.close();};/** * KeyframeRounder.prototype.run - Main 'helper' function which calls the other * methods of the KeyframeRounder object as well as handles some basic looping. * * @return {undefined}  None. */KeyframeRounder.prototype.run = function(){  this.filterProject();  this.setFrameRate();  for(var i = 0; i < this.projectItems.comps.length; i++){    this.fixInOutPoints(this.projectItems.comps[i]);    this.getTracks(this.projectItems.comps[i]);  }  pal.makeWindow();  pal.w.pbar.value = 0;  pal.w.pbar.maxvalue = this.keyCount;  for(var i = 0; i < this.tracks.length; i++){    this.fixKeys(this.tracks[i].track, this.tracks[i].fd, this.tracks[i].comp, this.tracks[i].layer);  }  pal.w.close();};KeyframeRounder.prototype.setFrameRate = function(){  var newfr = prompt('New Frame Rate:', '23.976', 'Enter Frame Rate');  newfr = parseFloat(newfr);  if(!newfr || isNaN(newfr)){    alert(newfr + ' is not a valid frame rate. Defaulting to 23.976');    newfr = 23.966;  }  this.fr = newfr;  this.fd = 1/this.fr;  for(var i = 0; i < this.projectItems.comps.length; i++){    this.projectItems.comps[i].frameDuration = this.fd;  }};/** * KeyframeRounder.prototype.getTracks - This method gets any properties which * are both animatable and have keyframes. * * @param  {CompObject} cmp The comp to search. * @return {undefined}     None. */KeyframeRounder.prototype.getTracks = function(cmp){  pal.makeWindow();  pal.w.pbar.value = 0;  pal.w.pbar.maxvalue = cmp.numLayers;  var checkProps = function(theProp, lyr){    if(theProp.numProperties > 0){  		for(var i = 1; i <= theProp.numProperties; ++i){  			checkProps(theProp.property(i), lyr);  		}  	} else {        if(theProp.canVaryOverTime && theProp.numKeys > 0 && theProp.name != 'Marker'){          animTracks.push({track:theProp, fd:cmp.frameDuration, comp:cmp, layer:lyr});          cnt += theProp.numKeys;        }  	}  }  var animTracks = [];  var cnt = 0;  for(var i = 1; i <= cmp.numLayers; i++){    for(var j = 1; j < cmp.layer(i).numProperties; j++){      checkProps( cmp.layer(i).property(j) , cmp.layer(i) );    }    pal.w.pbar.value = i+1;    pal.w.counter.text = 'Checking layer ' + i + ' of ' + cmp.numLayers + ' in comp ' + cmp.name;  }  for(var i = 0; i < animTracks.length; i++){    this.tracks.push(animTracks[i]);  }  this.keyCount += cnt;};/** * KeyframeRounder.prototype.fixKeys - The method which handles remaking the * keyframes. * * @param  {PropertyObject} trk The property with keyframes to round. * @param  {Number} fd  frame duration of the comp the property is in. * @return {undefined}     None. */KeyframeRounder.prototype.fixKeys = function(trk, fd, cmp, lyr){  if(trk.propertyValueType == PropertyValueType.CUSTOM_VALUE || trk.propertyValueType == PropertyValueType.NO_VALUE){    this.errors.push(trk.name + ' on layer ' + lyr.name + ' inside comp ' + cmp.name);    return;  }  if(trk.dimensionsSeparated && trk.name == 'Position'){    return;  }  if(trk.name == 'Time Remap' && trk.parentProperty.timeRemapEnabled == false){    return;  }  var keys = [];  for(var i = 1; i <= trk.numKeys; i++){    var keyProps = {      inInterp: false,      outInterp: false,      inSpatialTangent: false,      outSpatialTangent: false,      inTemporalEase: false,      outTemporalEase: false,      time:false,      val:false,      isRoving: false,      isSpatialAutoBezier: false,      isSpatialContinuous: false,      isTemporalAutoBezier: false,      isTemportalContinuous: false    };    keyProps.inInterp = trk.keyInInterpolationType(i);    keyProps.outInterp = trk.keyOutInterpolationType(i);    keyProps.val = trk.keyValue(i);    keyProps.time = trk.keyTime(i);    if(keyProps.inInterp == KeyframeInterpolationType.BEZIER && keyProps.outInterp == KeyframeInterpolationType.BEZIER){      keyProps.isTemporalAutoBezier = trk.keyTemporalAutoBezier(i);			keyProps.isTemportalContinuous = trk.keyTemporalContinuous(i);    }    if(keyProps.outInterp != KeyframeInterpolationType.HOLD){      keyProps.inTemporalEase = trk.keyInTemporalEase(i);      keyProps.outTemporalEase = trk.keyOutTemporalEase(i);    }    if ((trk.propertyValueType === PropertyValueType.TwoD_SPATIAL) || (trk.propertyValueType === PropertyValueType.ThreeD_SPATIAL)){			keyProps.isSpatialAutoBezier = trk.keySpatialAutoBezier(i);			keyProps.isSpatialContinuous = trk.keySpatialContinuous(i);			keyProps.inSpatialTangent = trk.keyInSpatialTangent(i);			keyProps.outSpatialTangent = trk.keyOutSpatialTangent(i);			keyProps.isRoving = trk.keyRoving(i);		}    keys.push(keyProps);  }  for (var i = trk.numKeys; i >= 1; i--){    trk.removeKey(i);  }  for(var i = 0; i < keys.length; i++){    // I don't understand why I need this here? Something in the loops above must be    // re-enabling time remapping after the initial check.    if(trk.name == 'Time Remap' && trk.parentProperty.timeRemapEnabled == false){continue;}    // Make the key.    trk.setValueAtTime(Math.floor(keys[i].time * (1/fd))/(1/fd), keys[i].val);    if (keys[i].outInterp != KeyframeInterpolationType.HOLD){			trk.setTemporalEaseAtKey(trk.numKeys, keys[i].inTemporalEase, keys[i].outTemporalEase);		}    trk.setInterpolationTypeAtKey(trk.numKeys, keys[i].inInterp, keys[i].outInterp);    if (keys[i].inInterp == KeyframeInterpolationType.BEZIER && keys[i].outInterp == KeyframeInterpolationType.BEZIER && keys[i].isTemportalContinuous){			trk.setTemporalContinuousAtKey(trk.numKeys, keys[i].isTemportalContinuous);			trk.setTemporalAutoBezierAtKey(trk.numKeys, keys[i].isTemporalAutoBezier);		}    if (trk.propertyValueType == PropertyValueType.TwoD_SPATIAL || trk.propertyValueType == PropertyValueType.ThreeD_SPATIAL){			trk.setSpatialContinuousAtKey(trk.numKeys, keys[i].isSpatialContinuous);			trk.setSpatialAutoBezierAtKey(trk.numKeys, keys[i].isSpatialAutoBezier);		// Implies Continuous, so do after it			trk.setSpatialTangentsAtKey(trk.numKeys, keys[i].inSpatialTangent, keys[i].outSpatialTangent);			trk.setRovingAtKey(trk.numKeys, keys[i].isRoving);		}  }};KeyframeRounder.prototype.fixInOutPoints = function (cmp) {  var fd = cmp.frameDuration;  for(var i = 1; i <= cmp.numLayers; i++){    var isLocked = cmp.layer(i).locked;    var isShyed = cmp.layer(i).shy;    cmp.layer(i).locked = false;    cmp.layer(i).shy = false;    var newSt = Math.floor(cmp.layer(i).startTime * (1/fd))/(1/fd);    var newIp = Math.floor(cmp.layer(i).inPoint * (1/fd))/(1/fd);    var newOp = Math.floor(cmp.layer(i).outPoint * (1/fd))/(1/fd);    cmp.layer(i).startTime = newSt;    cmp.layer(i).inPoint = newIp;    cmp.layer(i).outPoint = newOp;    cmp.layer(i).locked = isLocked;    cmp.layer(i).shy = isShyed;  }};KeyframeRounder.prototype.displayErrors = function(){  var title = 'Framerate conversion and keyframe adjustment complete!'  var baseText = 'I found ' + this.errors.length + ' properties that are of the CUSTOM_VALUE or NO_VALUE type. Keyframe adjustment did not take place on these properties. Please check and make sure there are no keys between frames.';  if(this.errors.length == 0) {    return alert(title + '\r\r' + 'No issues. Yay!')  } else {    return alert(title + '\r\r' + baseText + '\r\r' + this.errors.join('\r'));  }}app.beginUndoGroup('Round Keyframes to Whole Frames');var pal = new UIBuilder();var kfr = new KeyframeRounder;kfr.run();kfr.displayErrors();app.endUndoGroup();app.endUndoGroup();